"""    enemy.py        Defines a base class to make enemies"""import sysimport osimport mathsys.path.append("C:/Python27/proj/BetterConsoleFunctions/V3")import bcfout = bcfimport pygamefrom pygame.locals import *import app_constantsfrom app_constants import cwdfrom app_constants import makeRelativePathimport euclidimport rayimport environment# enemy classclass enemy:    """ pysiscs/game loop data """    state = "idle"    x_ = 0.0    y_ = 0.0    x_speed_ = 0.0    y_speed_ = 0.0        """ art/sound data """    textures_ = []        """ general data to override """    name_ = "enemy"    max_health_ = 0            # __init__ ()    def __init__ ( self ):        self.x_ = 0.0        self.y_ = 0.0        # override    # load ()    # should load all texture and audio data    # should call base method AT THE END to set colour keys    def load ( self ):        for t in self.textures_:            t.set_colorkey((255,0,255))        # override    # update ()    # called in the game loop, should do enemy logic and update the enemy    # should call the base method AT THE END    def update ( self ):        """ update x and y """        self.x_ += self.x_speed_        self.y_ += self.y_speed_        # override    # draw ()    # called in the game loop, should draw the enemy w/ animation or whatever    def draw ( self , ws):        pass        # warp ()    def warp ( self , x , y ):        self.x_ = x        self.y_ = y# test enemy classclass test_dummy (enemy):    """ general data """    name_ = "test dummy"    max_health_ = 10        """ timer data """    time_save_ = 0    flag1_ = 0    state_time_delay_ = 1000 # milliseconds        # __init__ ()    def __init__ ( self ):        self.state_ = "down"        self.time_save_ = pygame.time.get_ticks()        enemy.__init__( self )        # laod ()    def load ( self ):        self.textures_.append( pygame.image.load( makeRelativePath( "graphics/characters/test_dummy.png" ) ).convert() )        enemy.load( self )        # update ()    def update ( self ):        """ check if change of state is needed """        cur_time = pygame.time.get_ticks()        if cur_time - self.time_save_ >= self.state_time_delay_:            #import pdb; pdb.set_trace() # break point            self.time_save_ = cur_time            if self.state_ == "down":                if self.flag1_ == 0:                    self.state_ = "right"                elif self.flag1_ == 1:                    self.state_ = "left"            elif self.state_ == "right":                self.state_ = "down"                self.flag1_ = 1            elif self.state_ == "left":                self.state_ = "down"                self.flag1_ = 0                """ handle states """        if self.state_ == "down":            self.y_speed_ = 0.5            self.x_speed_ = 0.0        if self.state_ == "right":            self.y_speed_ = 0.0            self.x_speed_ = 0.5        if self.state_ == "left":            self.y_speed_ = 0.0            self.x_speed_ = -0.5                """ parent update. update x and y w/ speeds """        enemy.update( self )        # draw ()    def draw ( self , ws):        ws.blit(self.textures_[0], (self.x_,self.y_))