"""    object_factory.py        A class that can take in a gameinfo object and spawn the appropriate game objects in the context    """import sysimport osimport mathsys.path.append("C:/Python27/proj/BetterConsoleFunctions/V3")import bcfout = bcfimport pygamefrom pygame.locals import *import gameinfoimport objectimport laserimport wallimport e_dummyclass factory :    def __init__ ( self ) :        self.reset()    #/        def reset ( self ) :        self.enemy_list = [] # list of enemies currectly on screen (list of ints that represent indicies in the context's object list)        #self.laser_list = [] # list of laser currently on screen        #self.wall_list = [] # list of walls currently on screen        self.wave_list = [] # list of references to gameinfo wave objects        self.paused = False        self.ready = False # if the instance is ready to start creating enemies        self.started = False        self.c = None # reference to the context        # enemy spawning system        self.enemy_state = "idle"        self.delay = 0 # how long we have to wait for until the next action        self.wave_index = -1 # index of the wave we're on        self.enemy_index = -1 # the index of the enemy we're going to spawn next        self.timer_start = 0 # time when we start timing something        self.timer_pause = 0 # time elapsed whilst paused        self.timer_pause_start = 0 # time when the factory just got paused    #/        def setPause ( self , p ) :        if self.ready == False or self.started == False :            return        if self.paused == False and p == True :            # on game pause            self.timer_pause_start = pygame.time.get_ticks()        elif self.paused == True and p == False :            # on game UNpause            self.timer_pause += pygame.time.get_ticks() - self.timer_pause_start        self.paused = p    #/        def init ( self , gi , c) :        """ Sets up the object factory with respect to the gameinfo object 'gi' """        self.c = c        # create lasers        for laser_info in gi.laser_list :            l = laser.laser( laser_info.x , laser_info.y , laser_info.angle )            #self.laser_list.append( l )            c.addObject( l )        #/        # create walls        for wall_info in gi.wall_list :            w = wall.wall( wall_info.x1 , wall_info.y1 , wall_info.x2 , wall_info.y2 , wall_info.reflect )            #self.wall_list.append( w )            c.addObject( w )        #/        # set up enemy system        self.wave_list = gi.wave_list        # we're ready        self.ready = True    #/        def start ( self ) :        """ starts the object factory provided it has been initialised with a gameinfo object through 'init' """        if not self.ready :            return        # set the instance to have officialy 'started'        self.started = True        # 'start' the first wave        self.initNextWaveAction()    #/        def resetTimer ( self ) :        self.timer_start = pygame.time.get_ticks()        self.timer_pause = 0        self.timer_pause_start = 0    #/        def getTime ( self ) :        if not self.paused :            return pygame.time.get_ticks() - self.timer_start - self.timer_pause        else :            #return pygame.time.get_ticks() - self.timer_start - ( pygame.time.get_ticks() - self.timer_pause_start )            return -1    #/        def initNextWaveAction ( self ) :        out.pl("finished wave no. " + str(self.wave_index))        self.wave_index += 1        self.enemy_index = -1        self.delay = self.wave_list[ self.wave_index ].delay        out.pl("wating for " + str(self.delay) + " ms to start wave no. " + str(self.wave_index))        self.enemy_state = "wave"        self.resetTimer()        out.pl("current time " + str(self.getTime()) + " ms")    #/        def getCurrentEnemyRef ( self ) :        return self.wave_list[ self.wave_index ].enemy_list[ self.enemy_index ]    #/        def initNextEnemyAction ( self ) :        self.enemy_index += 1        self.delay = self.getCurrentEnemyRef().delay        out.pl("wating for " + str(self.delay) + " ms")        self.enemy_state = "enemy"        self.resetTimer()    #/        def spawnEnemy ( self ) :        e = None        if self.getCurrentEnemyRef().type == "dummy" :            e = e_dummy.e_dummy( self.getCurrentEnemyRef().x , self.getCurrentEnemyRef().y )        #/        # add enemy to context and add it's index to our enemy_list        self.enemy_list.append( self.c.addObject( e ) )    #/        def events ( self , event ) :        pass    #/        def tick ( self , c ) :        if self.ready == False or self.started == False :            return        """ enemy spawning logic """        if self.enemy_state == "wave" :            if self.getTime() > self.delay :                self.initNextEnemyAction()        #/        elif self.enemy_state == "enemy" :            if self.getTime() > self.delay :                # spawn the enemy                out.pl("Spawning enemy no. " + str( self.enemy_index ) + "")                self.spawnEnemy()                # check if this wave has finished                if self.enemy_index >= len( self.wave_list[ self.wave_index ].enemy_list ) - 1 :                    # check if this is NOT the last wave                    if self.wave_index < len( self.wave_list ) - 1 :                        self.initNextWaveAction()                    else :                        # this was the last wave                        self.enemy_state = "idle"                        out.pl("Finished spawning enemies")                else :                    self.initNextEnemyAction()        #/    #/        def draw ( self , wsurface ) :        """            objects will be drawn by the context,            so this method will only be used to draw other things like debug stats        """        pass    #/#/