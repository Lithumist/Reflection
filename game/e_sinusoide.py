"""    e_sinusoide.py        Sinusoide enemy (Game object)"""import sysimport osimport mathsys.path.append("C:/Python27/proj/BetterConsoleFunctions/V3")import bcfout = bcfimport pygamefrom pygame.locals import *import objectparentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))os.sys.path.insert(0,parentdir)from resource import TEXTURES,FONTSimport euclidimport physicsworld.stateimport physicsworld.rayimport physicsworld.drawclass e_sine ( object.object ) :    def __init__ ( self , x , y ) :        object.object.__init__( self )        self.x = x        self.y = y        self.y_speed = 1        self.x_speed_multiplier = 5        self.x_speed_angle = 0                self.inv_max = 120        self.inv_time = 0        self.inv = False                self.isEnemy = True                TEXTURES.sine = "graphics/characters/sine.png"        TEXTURES.sine_inv = "graphics/characters/sine_inv.png"        self.texture = -1        self.texture_inv = -1                self.radius = 9                self.maxhp = 2        self.hp = self.maxhp                self.reflect = True                self.pw_object = -1 # index of the physicsworld object                self.dead = False # dead flag.        self.remove_life = False # when True the calling code will take a life off the player    #/        def load ( self ) :        # load textures        self.texture = TEXTURES.sine        self.texture_inv = TEXTURES.sine_inv                # add physicsworld object        o = physicsworld.object.object( 1 , self.reflect , False , self.x , self.y , self.radius )        self.pw_object = physicsworld.state.addObject( o )    #/        def events ( self , events ):        pass    #/        def tick ( self ) :        if self.dead :            return        # update x speed        self.x_speed_angle += 4        if self.x_speed_angle > 360 :            self.x_speed_angle = 0        self.x_speed = math.sin( math.radians( self.x_speed_angle ) ) * self.x_speed_multiplier        # update inv        if self.inv == True :            self.inv_time += 1            if self.inv_time >= self.inv_max :                self.inv = False                physicsworld.state.objects[ self.pw_object ].ignore = False        # update positions        object.object.tick( self )        physicsworld.state.objects[ self.pw_object ].x = int( self.x + 5)        physicsworld.state.objects[ self.pw_object ].y = int( self.y + 1)        physicsworld.state.objects[ self.pw_object ].radius = int( self.radius )        # check if now outside screen        if self.hasBeenOnScreen == True and self.isOnScreen == False :            out.pl("enemy off screen, removing physicsworld object and life")            self.remove_life = True            self.dead = True        # check if has been shot        if physicsworld.state.objects[ self.pw_object ].hit == True and physicsworld.state.objects[ self.pw_object ].hit_deg > 0 and self.hasBeenOnScreen == True :            if self.inv == False:                 self.hp -= physicsworld.state.objects[ self.pw_object ].hit_deg                if self.hp <= 0 :                    out.pl("enemy killed with degree " + str(physicsworld.state.objects[ self.pw_object ].hit_deg) + ", killing and removing pw pbject")                    self.dead = True                else :                    self.inv = True                    self.inv_time = 0                    physicsworld.state.objects[ self.pw_object ].ignore = True        # remove physicsworld object if dead        if self.dead :            physicsworld.state.delObject( self.pw_object )                #/        def draw ( self , wsurface ) :        # draw texture        if self.inv == False :            wsurface.blit( self.texture , (self.x-self.radius , self.y-self.radius) )        else :            wsurface.blit( self.texture_inv , (self.x-self.radius , self.y-self.radius) )    #/#/