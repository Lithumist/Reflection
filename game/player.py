"""    player.py        A game 'object' that represents the player"""import sysimport osimport mathsys.path.append("C:/Python27/proj/BetterConsoleFunctions/V3")import bcfout = bcfimport pygamefrom pygame.locals import *import objectparentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))os.sys.path.insert(0,parentdir)from resource import TEXTURES,FONTSimport euclidimport physicsworld.stateimport physicsworld.rayimport physicsworld.drawclass player ( object.object ) :    def __init__ ( self ) :        object.object.__init__( self )                self.radius = 20                self.rotation = 0                TEXTURES.player40 = "graphics/characters/player40.png"        self.texture = 0                self.pw_object = -1  # index of the physicsworld object                self.x_acceleration = 0.1        self.y_acceleration = 0.1        self.angle_multiplier = 2 # how much to rotate by when going left and right                self.MOVE_LEFT = False        self.MOVE_RIGHT = False        self.MOVE_UP = False        self.MOVE_DOWN = False                self.pw_ray = None # the physicsworld ray that comes out of the player        self.ray_offset = 5 # distance the ray starts at from the edge of the player's circle        self.nvec_mouse = euclid.Vector2(1,1) # unit vector from centre of player to cursor coordinates    #/        def load ( self ) :        self.texture = TEXTURES.player40                # add the physicsworld object        o = physicsworld.object.object( 1 , True , False , self.x , self.y , self.radius )        self.pw_object = physicsworld.state.addObject( o )                # calculate ray object        cx, cy = pygame.mouse.get_pos()        self.nvec_mouse = euclid.Vector2( cx-self.x , cy-self.y )        self.nvec_mouse.normalize()        start_as_point = euclid.Point2( self.x + (self.nvec_mouse.x * ( self.radius + self.ray_offset ) )  ,  self.y + (self.nvec_mouse.y * ( self.radius + self.ray_offset ) )  )        self.pw_ray = physicsworld.ray.calculateRaySequence( start_as_point , self.nvec_mouse )    #/        def events ( self , events ) :        keys = pygame.key.get_pressed()        # do movement controls        if keys[pygame.K_LEFT] or keys[pygame.K_a] :            self.MOVE_LEFT = True        else :            self.MOVE_LEFT = False        #        if keys[pygame.K_RIGHT] or keys[pygame.K_d] :            self.MOVE_RIGHT = True        else :            self.MOVE_RIGHT = False        #        if keys[pygame.K_UP] or keys[pygame.K_w] :            self.MOVE_UP = True        else :            self.MOVE_UP = False        #        if keys[pygame.K_DOWN] or keys[pygame.K_s] :            self.MOVE_DOWN = True        else :            self.MOVE_DOWN = False    #/        def tick ( self ) :        # do physics        if self.MOVE_LEFT :            self.x_speed -= self.x_acceleration        if self.MOVE_RIGHT :            self.x_speed += self.x_acceleration        if self.MOVE_UP :            self.y_speed -= self.y_acceleration        if self.MOVE_DOWN :            self.y_speed += self.y_acceleration        # update angle        self.rotation -= self.x_speed * self.angle_multiplier        if self.rotation < 0 :            dif = 0 - self.rotation            self.rotation = 360 - dif        if self.rotation > 360 :            dif = self.rotation - 360            self.rotation = dif        # update ray        cx, cy = pygame.mouse.get_pos()        self.nvec_mouse = euclid.Vector2( cx-self.x , cy-self.y )        self.nvec_mouse.normalize()        start_as_point = euclid.Point2( self.x + (self.nvec_mouse.x * ( self.radius + self.ray_offset ) )  ,  self.y + (self.nvec_mouse.y * ( self.radius + self.ray_offset ) )  )        self.pw_ray = physicsworld.ray.calculateRaySequence( start_as_point , self.nvec_mouse )        # update position        self.x += self.x_speed        self.y += self.y_speed        physicsworld.state.objects[ self.pw_object ].x = int( self.x )        physicsworld.state.objects[ self.pw_object ].y = int( self.y )        physicsworld.state.objects[ self.pw_object ].radius = int( self.radius )    #/        def gamePaused ( self ) :        pass    #/        def gameUnpaused ( self ) :        pass    #/        def draw ( self , wsurface) :        # rotate player sprite and blit        orig_rect = self.texture.get_rect()        rot_image = pygame.transform.rotate(self.texture, self.rotation)        rot_rect = orig_rect.copy()        rot_rect.center = rot_image.get_rect().center        texture_rotated = rot_image.subsurface(rot_rect).copy()        wsurface.blit( texture_rotated , (self.x-self.radius , self.y-self.radius) )        # draw player's ray        physicsworld.draw.drawRaySeq( wsurface , self.pw_ray )    #/#/