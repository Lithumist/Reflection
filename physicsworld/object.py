"""    physcisworld/object.py        class 'object'    a physics object class that calculations can be performed on.""""""    'type' table        0   line      properties:      - x1      - y1      - x2      - y2        1   circle      properties      - x (centre)      - y (centre)      - radius"""unittest = Falseimport syssys.path.append("C:/Python27/proj/BetterConsoleFunctions/V3")import bcfout = bcfclass object:        def __init__ ( self , t=1 , ref=False , ren=False , data1=0.0 , data2=0.0 , data3=0.0 , data4=0.0 ):        self.reflects = ref        self.render = ren        self.type = t        self.hit = False        self.hit_deg = 0        # create data attributes corresponding to the type given        if t == 0: # line            self.x1 = int(data1)            self.y1 = int(data2)            self.x2 = int(data3)            self.y2 = int(data4)        elif t == 1: # circle            self.x = int(data1)            self.y = int(data2)            self.radius = int(data3)        def move ( self , dx , dy ):        if self.type == 0: # line            self.x1 += int(dx)            self.y1 += int(dy)            self.x2 += int(dx)            self.y2 += int(dy)        elif self.type == 1: # circle            self.x += int(dx)            self.y += int(dy)        def warp ( self , nx , ny ):        if self.type == 0: # line            self.x2 = int((self.x2-self.x1) + nx)            self.y2 = int((self.y2-self.y1) + ny)            self.x1 = int(nx)            self.y1 = int(ny)        if self.type == 1: # circle            self.x = int(nx)            self.y = int(ny)if unittest :    obj1 = object( 0 , True , False , 1 , 2 , 3 , 4 )        assert(obj1.type == 0)    out.pl("ok")        assert(obj1.x1 == 1.0)    out.pl("ok")        obj1.move( 10 , 0 )        assert(obj1.x1 == 11)    out.pl("ok")        assert(obj1.x2 == 13.0)    out.pl("ok")        assert(obj1.y1 == 2.0)    out.pl("ok")