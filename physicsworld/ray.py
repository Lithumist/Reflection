"""    ray.py        methods and variables for performing ray calculations on the state    updates variables in state"""unittest = Falseimport sysimport mathsys.path.append("C:/Python27/proj/BetterConsoleFunctions/V3")import bcfout = bcfimport utilimport objectimport statefrom .. import euclid# global reflection limitmax_reflections = 1class ray:        def __init__ ( self , copy_ray=euclid.Ray2(euclid.Point2(),euclid.Vector2(1,1)) , copy_end=None ):        assert(isinstance(copy_ray , euclid.Ray2))        #assert(isinstance(copy_end , euclid.Point2) or isinstance(copy_end , None))        self.e_ray = copy_ray # euclid's representation of the ray        self.end_point = copy_end # the point at whcih the ray ends        # getUnitVector() - returns an euclid.Vector2    # relies on accurate e_ray and end_point data attributes    def getUnitVector ( self ):        """        len = math.sqrt( pow(self.end_point.x - self.e_ray.v.x, 2)  +  pow(self.end_point.y - self.e_ray.v.y, 2) )        vec = self.e_ray.v        vec.x = vec.x / len        vec.y = vec.y / len        return vec        """        return self.e_ray.v.normalized()        # restricts the ray to an euclid.Point2    def restrict ( self , end_point):        assert(isinstance(end_point , euclid.Point2))        self.end_point = end_point        # removes the end point restriction    def unrestrict ( self ):        self.end_point = Noneclass ray_seq:        def __init__ ( self ):        self.ray_list = []        # clearRayList()    def clearRayList ( self ):        self.ray_list = []        # addRay    # adds a ray to ray_list    # intended to be used internally    def addRay ( self , e_ray , end_point=None ):        assert isinstance(e_ray , euclid.Ray2)        #assert isinstance(end_point , euclid.Point2) or isinstance(end_point , None)        self.ray_list.append( ray(  e_ray , end_point  ) )        # calculate()    # populates ray_list    # uses 'objects' from state.py    # 'deg' argument used for recursion: indicates which ray in the ray_list we are calulcating    """        optimisation idea 1:        - approximate all objects and current ray to bounding rectangles        - check for collisions with these (broad phase)        - if any collisions, do precise intersection point calculation    """    def calculate ( self , deg=0 ):        global max_reflections        # clear all but the first ray if this is first pass        if deg == 0:            self.ray_list[1:] = []        # STEP 1        #   find an intersection point w/ any physics object        # ######        best_int = None # closest intersection point        new_int = None # newset intersection point calculated        best_int_type = None # the type of object best_int represents an intersection point with. 0=line, 1=circle        best_int_obj = None # a copy of the object that we got the closest intersection point        for index, obj in enumerate( state.objects ):            #import pdb; pdb.set_trace() # break point            if obj is None:                # we've found a none type, skip it                continue            if obj.type == 0:                out.pl("line line line!")                out.pl("deg " + str(deg))                # object is a line                # construct an euclid line segment                lineseg = euclid.Line2( euclid.Point2(obj.x1,obj.y1) , euclid.Point2(obj.x2,obj.y2))                new_int = lineseg.intersect( self.ray_list[deg].e_ray )                if isinstance(new_int, euclid.Point2):                    # intersect!                    out.pl("line intersection!")                    if best_int is None:                        best_int = new_int                        best_int_type = 0                        best_int_obj = obj                    else:                        v1 = euclid.Vector2( new_int.x-self.ray_list[deg].e_ray.p1.x , new_int.y-self.ray_list[deg].e_ray.p1.y ) # vector to new intersection                        v2 = euclid.Vector2( best_int.x-self.ray_list[deg].e_ray.p1.x , best_int.y-self.ray_list[deg].e_ray.p1.y ) # vector to old best intersection                        if v1.magnitude_squared() < v2.magnitude_squared():                            # new_int replaces best_int because it's closer                            best_int = new_int                            best_int_type = 0                            best_int_obj = obj            elif obj.type == 1:                out.pl("hmm smells like a circle over here")                out.pl("deg " + str(deg))                # object is a circle                # construct an euclid circle                circle = euclid.Circle( euclid.Vector2(obj.x,obj.y) , float(obj.radius) )                out.pl(str(circle))                out.pl(str(self.ray_list[deg].e_ray))                new_int = circle.intersect( self.ray_list[deg].e_ray )                if isinstance(new_int, euclid.LineSegment2):                    if not new_int.p1 == new_int.p2: # prevent tangential intersections                        # intersect!                        out.pl("circle intersection!")                        #import pdb; pdb.set_trace() # break point                        new_int = util.closer(self.ray_list[deg].e_ray.p1 , new_int.p1 , new_int.p2)                        if best_int is None:                            best_int = new_int                            best_int_type = 1                            best_int_obj = obj                        else:                            v1 = euclid.Vector2( new_int.x-self.ray_list[deg].e_ray.p1.x , new_int.y-self.ray_list[deg].e_ray.p1.y ) # vector to new intersection                            v2 = euclid.Vector2( best_int.x-self.ray_list[deg].e_ray.p1.x , best_int.y-self.ray_list[deg].e_ray.p1.y ) # vector to old best intersection                            if v1.magnitude_squared() < v2.magnitude_squared():                                # new_int replaces best_int because it's closer                                best_int = new_int                                best_int_type = 1                                best_int_obj = obj        # STEP 2        #  - exit the method if no intersections were found.        #  - move the intersection point back along the incident vector a tiny bit (to prevent internal reflection)        #  - restrict the incident ray's length to the intersection point.        #  - exit the method if we're past the max reflection limit or if the object does not reflect rays.        # ######        if best_int is None:            self.ray_list[deg].unrestrict()            return                inc_vec = self.ray_list[deg].getUnitVector() # incident vector        best_int.x -= inc_vec.x * 2        best_int.y -= inc_vec.y * 2        self.ray_list[deg].restrict( best_int )        if (deg >= max_reflections) or (best_int_obj.reflects == False):            return        # STEP 3        #   calculate the unit normal vector of the object        # ######        if best_int_type == 0:            #tangent = euclid.Line2( euclid.Point2(best_int_obj.x1, best_int_obj.y1) , euclid.Point2(best_int_obj.x2, best_int_obj.y2))            dx = best_int_obj.x2 - best_int_obj.x1            dy = best_int_obj.y2 - best_int_obj.y1            normal = euclid.Vector2( -dy , dx )            normal.normalize()        elif best_int_type == 1:            normal = euclid.Vector2( best_int.x-best_int_obj.x , best_int.y-best_int_obj.y )            normal.normalize()        # STEP 4        #   calculate reflected vector        # ######        #iv = euclid.Vector2( best_int.x-self.ray_list[deg].e_ray.p1.x , best_int.y-self.ray_list[deg].e_ray.p1.y ) # incident vector        iv = self.ray_list[deg].getUnitVector() # incident vector        rv = iv.reflect(normal) # reflected vector        # STEP 5        #   append reflected ray and recurse if necessary        # ######        self.ray_list.append(ray(euclid.Ray2(  best_int , rv  )))                if deg < max_reflections:            self.calculate(deg+1)"""    general methods here"""# calculateRaySequence()# returns a ray_seqdef calculateRaySequence ( start_point , direction_vector ):    #assert isinstance(start_point , euclid.Point2)    #assert isinstance(direction_vector , euclid.Vector2)    rs = ray_seq()    rs.addRay( euclid.Ray2(start_point , direction_vector) )    rs.calculate()    return rs