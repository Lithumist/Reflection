"""    ray.py        methods and variables for performing ray calculations on the state    updates variables in state"""unittest = Falseimport sysimport mathsys.path.append("C:/Python27/proj/BetterConsoleFunctions/V3")import bcfout = bcfimport utilimport objectimport statefrom .. import euclid# global reflection limitmax_reflections = 5class ray:        def __init__ ( self , copy_ray=euclid.Ray2(euclid.Point2(),euclid.Vector2(1,1)) , copy_end = euclid.Point2() ):        assert(isinstance(copy_ray , euclid.Ray2))        assert(isinstance(copy_end , euclid.Point2))        self.e_ray = copy_ray # euclid's representation of the ray        self.end_point = copy_end # the point that the ray ends        # getUnitVector() - returns an euclid.Vector2    # relies on accurate e_ray and end_point data attributes    def getUnitVector ( self ):        len = math.sqrt( pow(self.end_point.x - self.e_ray.v.x, 2)  +  pow(self.end_point.y - self.e_ray.v.y, 2) )        vec = self.e_ray.v        vec.x = vec.x / len        vec.y = vec.y / len        return vec        # restricts the ray to an euclid.Point2    def restrict ( self , end_point):        assert(isinstance(end_point , euclid.Point2))        self.end_point = end_pointclass ray_seq:        def __init__ ( self ):        self.ray_list = []        # clearRayList()    def clearRayList ( self ):        self.ray_list = []        # addRay    # adds a ray to ray_list    # intended to be used internally    def addRay ( self , e_ray , end_point ):        assert(isinstance(e_ray , euclid.Ray2))        assert(isinstance(end_point , euclid.Point2))        self.ray_list.append( ray(  e_ray , end_point  ) )        # calculate()    # populates ray_list    # uses 'objects' from state.py    """        optimisation idea 1:        - approximate all objects and current ray to bounding rectangles        - check for collisions with these (broad phase)        - if any collisions, do precise intersection point calculation    """    def calculate ( self ):        pass"""    general methods here"""# calculateRaySequence()# returns a ray_seqdef calculateRaySequence ( start_point , direction_vector ):    assert(isinstance(start_point , euclid.Point2))    assert(isinstance(direction_vector , euclid.Vector2))    rs = ray_seq()    rs.calculate()    return rs