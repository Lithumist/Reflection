"""    ray.py        methods and variables for performing ray calculations on the state    updates variables in state"""unittest = Falseimport sysimport mathsys.path.append("C:/Python27/proj/BetterConsoleFunctions/V3")import bcfout = bcfimport utilimport objectimport statefrom .. import euclid# global reflection limitmax_reflections = 5class ray:        def __init__ ( self , copy_ray=euclid.Ray2(euclid.Point2(),euclid.Vector2(1,1)) , copy_end = euclid.Point2() ):        assert(isinstance(copy_ray , euclid.Ray2))        assert(isinstance(copy_end , euclid.Point2))        self.e_ray = copy_ray # euclid's representation of the ray        self.end_point = copy_end # the point that the ray ends        # getUnitVector() - returns an euclid.Vector2    # relies on accurate e_ray and end_point data attributes    def getUnitVector ( self ):        len = math.sqrt( pow(self.end_point.x - self.e_ray.v.x, 2)  +  pow(self.end_point.y - self.e_ray.v.y, 2) )        vec = self.e_ray.v        vec.x = vec.x / len        vec.y = vec.y / len        return vec        # restricts the ray to an euclid.Point2    def restrict ( self , end_point):        assert(isinstance(end_point , euclid.Point2))        self.end_point = end_pointclass ray_seq:        def __init__ ( self ):        self.ray_list = []        # clearRayList()    def clearRayList ( self ):        self.ray_list = []        # addRay    # adds a ray to ray_list    # intended to be used internally    def addRay ( self , e_ray , end_point ):        assert(isinstance(e_ray , euclid.Ray2))        assert(isinstance(end_point , euclid.Point2))        self.ray_list.append( ray(  e_ray , end_point  ) )        # calculate()    # populates ray_list    # uses 'objects' from state.py    # 'deg' argument used for recursion: indicates which ray in the ray_list we are calulcating    """        optimisation idea 1:        - approximate all objects and current ray to bounding rectangles        - check for collisions with these (broad phase)        - if any collisions, do precise intersection point calculation    """    def calculate ( self , deg=0 ):        # clear all but the first ray if this is first pass        if deg == 0:            self.ray_list[1:] = []        # check for intersection with physics objects        best_int = None # closest intersection point        new_int = None # newset intersection point calculated        for index, obj in enumerate( state.objects ):            if obj.type == 0:                # object is a line, construct euclid line segment                lineseg = euclid.Line2( euclid.Point2(obj.x1,obj.y1) , euclid.Point2(obj.x2,obj.y2))                new_int = lineseg.intersect( self.ray_list[deg].e_ray )                if isinstance(new_int,euclid.Point2):                    # intersect!                    pass"""    general methods here"""# calculateRaySequence()# returns a ray_seqdef calculateRaySequence ( start_point , direction_vector ):    assert(isinstance(start_point , euclid.Point2))    assert(isinstance(direction_vector , euclid.Vector2))    rs = ray_seq()    rs.addRay( euclid.Ray2(start_point , direction_vector) )    rs.calculate()    return rs